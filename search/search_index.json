{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"rich-codex \u26a1\ufe0f\ud83d\udcd6\u26a1\ufe0f","text":"<p>A GitHub Action / command-line tool which generates screengrab images of a terminal window, containing command outputs or code snippets.</p> <p></p>"},{"location":"#introduction","title":"Introduction","text":"<p>Having code examples in your documentation is a fantastic way to help users understand what to expect from your tool.</p> <p>Using terminal screenshots is a good way to do this because:</p> <ul> <li>\ud83c\udf08 Coloured terminal output is supported</li> <li>\u2194\ufe0f You can fit in long lines without scrolling or cropping (images are auto-resized)</li> <li>\ud83d\ude0e They look cool</li> </ul> <p>However, manually generating these screenshots is a pain \ud83d\udc4e\ud83c\udffb Remembering to update them every time you make a minor change means that they can easily get out of date.</p> <p>Rich-codex automates this process for you. It searches markdown code for images with shell commands or code snippets. It runs these commands and saves a terminal screen-grab at the embedded path.</p> <p>Typical use cases:</p> <ul> <li>\ud83d\udcf7 Example CLI tool outputs that automatically stay in sync with your package</li> <li>\u267b\ufe0f Syntax-highlighted code snippets that are always up to date with your <code>examples/</code></li> <li>\ud83e\udd29 Fast and simple images for your docs with minimal setup</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<ol> <li>\ud83d\udcd6 Write some markdown docs, use an image tag with a backtick command inside:    </li> </ol> <p><pre><code>![`cat cat.txt | lolcat -S 1`](img/cat.svg)\n</code></pre> 2. \ud83e\udd16 Add a GitHub Action to automatically run the command, generate the image and commit to the repo:</p> <pre><code>on: [push]\njobs:\n  rich_codex:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Install your custom tools\n        run: pip install lolcat\n\n      - name: Generate terminal images with rich-codex\n        uses: ewels/rich-codex@v1\n        with:\n          commit_changes: \"true\"\n</code></pre> <ol> <li>\ud83c\udf08 Enjoy reading your documentation </li> </ol>"},{"location":"#how-it-works","title":"How it works","text":"<p>Rich-codex is a command-line tool that you can run via a GitHub action or as a command line tool. It works with any markdown (including GitHub READMEs).</p> <p>It collects either commands or code snippets, together with output filenames and configuration options. Commands are run in a subprocess and the standard output &amp; standard error collected. These are then rendered as an image using Textualize/rich.</p> <p>Tip</p> <p>Rich-codex creates the images that your markdown docs expect. It doesn't require a HTML build-step and doesn't make any changes to your markdown or its output. As such, it's compatible with any documentation engine, including rendering markdown on github.com.</p> <p>Rich-codex needs inputs (commands / snippets) and output filenames to work. These can be configured in four different ways:</p> <ul> <li>\ud83d\uddbc Markdown images<ul> <li>Search markdown files for image tags with command alt text. eg: <code>![`rich-codex --help`](img/rich-codex-help.svg)</code></li> </ul> </li> <li>\ud83d\udcac Markdown comments<ul> <li>Search markdown files for special HTML comments.</li> </ul> </li> <li>\u27a1\ufe0f Command-line / action inputs<ul> <li>Specify a command or snippet using the action <code>with</code> inputs.</li> </ul> </li> <li>\u2699\ufe0f Config files<ul> <li>Use one or more YAML config files for multiple images and more complex customisation.</li> </ul> </li> </ul> <p>Images can be generated as SVG, PNG or PDF (detected by filename extension).</p>"},{"location":"safety/","title":"Safety","text":"<p>\ud83d\udca5\u26a0\ufe0f Warning \u26a0\ufe0f\ud83d\udca5</p> <p>Reminder: rich-codex runs arbitrary commands found in documentation on your host system. You are responsible for ensuring that it does not do any damage.</p>"},{"location":"safety/#prompts-for-commands","title":"Prompts for commands","text":"<p>When rich-codex runs interactively, it collects all commands to be run and presents these to you, the user. You then need to choose whether to run all commands, choose some or to ignore all of them.</p> <p>You can disable these checks by using the <code>--no-confirm</code> CLI flag / setting env var <code>$NO_CONFIRM</code>.</p>"},{"location":"safety/#banned-commands","title":"Banned commands","text":"<p>As a very basic safety step, rich-codex attempts to ignore any commands that start with the following: <code>rm</code>, <code>cp</code>, <code>mv</code>, <code>sudo</code>. This is to avoid accidentally messing with your local system.</p> <p>Please note that this is only for rough protection against accidents and would be easy for a malicious user to circumvent (for example, putting these commands in a bash script and running that).</p>"},{"location":"safety/#git-checks","title":"Git checks","text":"<p>By default, rich-codex checks that:</p> <ul> <li>You are running within a initialised git repository</li> <li>You do not have any uncommitted changes</li> </ul> <p>This is because rich-codex overwrites local files. If you're running within a clean git repo you can easily see what has been changed and revert it.</p> <p>You can disable these checks by using the <code>--skip-git-checks</code> CLI flag / setting env var <code>$SKIP_GIT_CHECKS</code>.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#no-image-generated","title":"No image generated","text":"<p>First up: did you remember the <code>!</code>? It's <code>![`command`](path)</code> - I've spent longer than I'd care to admit debugging only to realise I missed the leading <code>!</code> \ud83d\ude48</p> <p>Next, check the verbose log - it's saved as an artefact with GitHub Actions or locally you can use the <code>-v</code>/<code>--verbose</code> flag. The verbose log tells you which files are being searched and gives you more insight into what rich-codex is doing.</p>"},{"location":"troubleshooting/#cant-push-new-commits","title":"Can't push new commits","text":"<p>If you're fairly new to using git, you might find this error message a bit intimidating when you first see it:</p> <p></p> <p>Fear not, what has likely happened is:</p> <ul> <li>Your rich-codex GitHub Action has run since you last pushed</li> <li>It created some new images and you have set it to automatically commit these new images to your repository</li> <li>Because of this, your git remote now has new commits that you don't yet have locally</li> <li>Git doesn't let you push your work until that's resolved</li> </ul> <p>The fix is usually simple - you need to pull the new commits and tell git to rebase your new work on top of that. Git will shuffle the commits one in front of the other and then you'll be able to push without any issues:</p> <p></p> <p></p>"},{"location":"config/cleaning/","title":"Removing images","text":"<p>If you change the output filename of an image, a new file will be created. However, the old one will remain which is probably not what you intended.</p> <p>To avoid this rich-codex can \"clean\" an image path, deleting any matching files that were not generated during a run.</p> <p>This is done using <code>--clean-img-paths</code> / <code>$CLEAN_IMG_PATHS</code> / <code>clean_img_paths</code> (CLI, env var, action/config). One or more filename glob patterns (separated by newlines) can be given. At the end of the run, all matching files that were not generated will be deleted.</p> <p>Warning</p> <p>Rich-codex will clean all files matching your pattern. Including your source code. Handle with care \ud83d\udd25</p>"},{"location":"config/colours/","title":"Colours","text":""},{"location":"config/colours/#using-a-pseudo-terminal","title":"Using a pseudo-terminal","text":"<p>By default, rich-codex runs commands in a Python <code>subprocess</code>. This is not an interactive terminal, and as such many command-line tools will disable coloured output.</p> <p>This is best solved at the tool level if possible, by telling the tool to force coloured output. However, if this is not possible then you can use <code>--use-pty</code> / <code>$USE_PTY</code> / <code>use_pty</code> (CLI, env var, action/config). This uses a Python <code>pty</code> pseudo-terminal instead of <code>subprocess</code> which may trick your tool into keeping coloured output.</p> <p>Warning</p> <p>Note that PTY almost certainly won't work on Windows and is generally more likely to do weird stuff / create poorly formatted outputs than the default subprocess shell.</p>"},{"location":"config/colours/#colour-theme","title":"Colour theme","text":"<p>You can customise the theme using <code>--terminal-theme</code> / <code>$TERMINAL_THEME</code> / <code>terminal_theme</code> (CLI, env, action/config).</p> <p>Themes are taken from Rich, at the time of writing the following are available:</p> <ul> <li><code>DEFAULT_TERMINAL_THEME</code></li> <li><code>MONOKAI</code></li> <li><code>DIMMED_MONOKAI</code></li> <li><code>NIGHT_OWLISH</code></li> <li><code>SVG_EXPORT_THEME</code></li> </ul> <p>The terminal theme should be set as a string to one of these values.</p> <p>Note</p> <p>It's planned to add support for custom themes but not yet implemented. If you need this, please create a GitHub issue / pull-request.</p> <p><code>DEFAULT_TERMINAL_THEME</code>:</p> <p></p> <p><code>MONOKAI</code>:</p> <p></p> <p><code>DIMMED_MONOKAI</code>:</p> <p></p> <p><code>NIGHT_OWLISH</code>:</p> <p></p> <p><code>SVG_EXPORT_THEME</code>:</p> <p></p>"},{"location":"config/colours/#snippet-colours","title":"Snippet colours","text":"<p>Snippets are formatted using rich Syntax objects. These use Pygments to add code colouring, which has its own set of themes - separate to the terminal theme that the snippet is wrapped in.</p> <p>As such, if using snippets, you'll probably want to set both the terminal theme and the Pygments style. You can find available Pygments styles in the Pygments docs.</p> <p><code>snippet_theme: xcode</code> + <code>terminal_theme: DEFAULT_TERMINAL_THEME</code>:</p> <p></p> <p><code>snippet_theme: monokai</code> + <code>terminal_theme: SVG_EXPORT_THEME</code>:</p> <p></p> <p><code>snippet_theme: fruity</code> + <code>terminal_theme: MONOKAI</code>:</p> <p></p>"},{"location":"config/command_setup/","title":"Command setup","text":""},{"location":"config/command_setup/#setting-extra-environment-vars","title":"Setting extra environment vars","text":"<p>In some cases you may want to set environment variables for a single command only. In this case, you can use the <code>extra_env</code> config option, which adds YAML key:value pairs to the environment for just that command (and the before / after commands, see below).</p> <p>I use this method to set the terminal width for the rich-codex screenshots in this documentation:</p> <pre><code>&lt;!-- RICH-CODEX\nterminal_width: 120\nnotrim: true\nextra_env:\n  TERMINAL_WIDTH: 120\n--&gt;\n![`rich-codex --help`](../img/rich-codex-cli-envs.svg)\n</code></pre> <p>Tip</p> <p>It's probably easier to set these at run-level if that's an option, these are really only if you want to customise for a single output.</p>"},{"location":"config/command_setup/#faking-simple-commands","title":"Faking simple commands","text":"<p>Sometimes you may need to have long complicated commands to get the screenshot you need, when the typical command for an end user would be much simpler.</p> <p>In this case, you can fake the command shown in the terminal prompt using <code>--fake-command</code> / <code>$FAKE_COMMAND</code> / <code>fake_command</code>.</p> <p>For example:</p> <p><pre><code>&lt;!-- RICH-CODEX fake_command: \"my_tool --is-simple\" --&gt;\n![`echo \"I won't tell if you don't \ud83e\udd2b\" &gt; temp_file.txt &amp;&amp; echo \"\" &amp;&amp; cat temp_file.txt &amp;&amp; rm temp_file.txt`](../img/fake_command.svg)\n</code></pre> </p>"},{"location":"config/command_setup/#running-commands-before-and-after","title":"Running commands before and after","text":"<p>Chaining complex commands may not always work if the setup / cleanup commands generate output that you don't want to show in the screenshot.</p> <p>In these more complex scenarios, you can run additional commands before and after the one used for the screenshot. This is done with the following options:</p> <ul> <li><code>--before-command</code> / <code>$BEFORE_COMMAND</code> / <code>before_command</code></li> <li><code>--after-command</code> / <code>$AFTER_COMMAND</code> / <code>after_command</code>.</li> </ul> <p>These run separate <code>subprocess</code> calls with the specified commands before and after the target command. This can be useful for initialising an environment and then cleaning up afterwards.</p> <p>For example:</p> <p><pre><code>&lt;!-- RICH-CODEX\nbefore_command: &gt;\n  echo \"This is a very simple example\" &gt; before_after_command_example.txt\nafter_command: rm before_after_command_example.txt\n--&gt;\n![`cat before_after_command_example.txt`](../img/before_after_command.svg)\n</code></pre> </p> <p>!!! note:     Commands should be a single string, so remember to chain using <code>&amp;&amp;</code> and ideally use YAML multi-line strings that collapse newlines using <code>&gt;</code>.</p>"},{"location":"config/ignoring_changes/","title":"Ignoring changes","text":"<p>You may find that your screenshots are changing every time you run rich-codex, even though no relevant changes have occured within your code. This could be because the screenshots include timestamps or some other live data.</p> <p>To avoid doubling your commit count with changes that you don't care about, rich-codex has two mechanisms which you can use to ignore changes:</p> <ul> <li>\u2696\ufe0f Percentage change in file contents</li> <li>\ud83d\udd0e Regular expression matches</li> </ul>"},{"location":"config/ignoring_changes/#percentage-change-in-file-contents","title":"Percentage change in file contents","text":"<p>When you run rich-codex, any new images created will generate log messages that look like this: <code>Saved: 'docs/img/rich-codex-snippet-title.svg' (4.63% change)</code>. This percentage change is calculated using the python-Levenshtein package, comparing the raw bytes of the two files.</p> <p>By default, any new files with 0.00% change will be ignored. If you find that you have screenshots changing by the same small percentage every time, you can raise this threshold by setting <code>--min-pct-diff</code> / <code>$MIN_PCT_DIFF</code> / <code>min_pct_diff</code> (CLI, env var, action/config).</p> <p>For example, if a timestamp caused this file to change by 4.34% on every commit, those changes could be ignored as follows:</p> <pre><code>&lt;!-- RICH-CODEX min_pct_diff: 5 --&gt;\n![`rich-codex --help`](../img/rich-codex-help-min-pct.svg)\n</code></pre>"},{"location":"config/ignoring_changes/#regular-expression-matches","title":"Regular expression matches","text":"<p>Percentage changes in files is quick and simple, but a little crude. If you prefer, you may be able to use regular expressions instead with <code>--skip-change-regex</code> / <code>$SKIP_CHANGE_REGEX</code> / <code>skip_change_regex</code> (CLI, env var, action/config).</p> <p>If there is a &gt; 0% change in files, a rich diff will be generated. Any diff lines matching the supplied regexes will be removed and if none remain, the changeset will be ignored.</p> <p>Rich-codex ships with one default, applied for PDF files: if the only change is a line with <code>\"/CreationDate\"</code> then the changeset will be ignored.</p> <p>Warning</p> <p>Please note that generating diffs between file pairs can be very slow. Use with caution.</p>"},{"location":"config/overview/","title":"Overview","text":""},{"location":"config/overview/#config-locations","title":"Config locations","text":"<p>Rich-codex can be run in several different ways and get configuration from multiple different locations. They are, in order of parsing / precidence (last location wins):</p> <ul> <li>Global, for entire run:<ul> <li>GitHub Action arguments</li> <li>Environment variables</li> <li>Command-line flags (CLI)</li> <li>Rich-codex config files (<code>.rich-codex.yml</code>)</li> </ul> </li> <li>Per-image:<ul> <li>Rich-codex config files (<code>.rich-codex.yml</code>)</li> <li>Markdown config</li> </ul> </li> </ul>"},{"location":"config/overview/#overview-of-all-options","title":"Overview of all options","text":"<p>An overview of all available config options in all scopes is below:</p> CLI Environment variable GitHub Action / Rich-codex config <code>--search-include</code> <code>SEARCH_INCLUDE</code> <code>search_include</code> <code>--search-exclude</code> <code>SEARCH_EXCLUDE</code> <code>search_exclude</code> <code>--no-search</code> <code>NO_SEARCH</code> <code>no_search</code> <code>--command</code> <code>COMMAND</code> <code>command</code> <code>--timeout</code> <code>TIMEOUT</code> <code>timeout</code> <code>--working-dir</code> <code>WORKING_DIR</code> <code>working_dir</code> <code>--before-command</code> <code>BEFORE_COMMAND</code> <code>before_command</code> <code>--after-command</code> <code>AFTER_COMMAND</code> <code>after_command</code> <code>--snippet</code> <code>SNIPPET</code> <code>snippet</code> <code>--snippet-syntax</code> <code>SNIPPET_SYNTAX</code> <code>snippet_syntax</code> <code>--img-paths</code> <code>IMG_PATHS</code> <code>img_paths</code> <code>--clean-img-paths</code> <code>CLEAN_IMG_PATHS</code> <code>clean_img_paths</code> <code>--configs</code> <code>RC_CONFIGS</code> <code>rc_configs</code> <code>--fake-command</code> <code>FAKE_COMMAND</code> <code>fake_command</code> <code>--hide-command</code> <code>HIDE_COMMAND</code> <code>hide_command</code> <code>--title-command</code> <code>TITLE_COMMAND</code> <code>title_command</code> <code>--head</code> <code>RC_HEAD</code> <code>head</code> <code>--tail</code> <code>RC_TAIL</code> <code>tail</code> <code>--trim-after</code> <code>TRIM_AFTER</code> <code>trim_after</code> <code>--truncated-text</code> <code>TRUNCATED_TEXT</code> <code>truncated_text</code> <code>--skip-git-checks</code> <code>SKIP_GIT_CHECKS</code> <code>skip_git_checks</code> <code>--no-confirm</code> <code>NO_CONFIRM</code> - <code>--min-pct-diff</code> <code>MIN_PCT_DIFF</code> <code>min_pct_diff</code> <code>--skip-change-regex</code> <code>SKIP_CHANGE_REGEX</code> <code>skip_change_regex</code> <code>--terminal-width</code> <code>TERMINAL_WIDTH</code> <code>terminal_width</code> <code>--terminal-min-width</code> <code>TERMINAL_MIN_WIDTH</code> <code>terminal_min_width</code> <code>--notrim</code> <code>NOTRIM</code> <code>notrim</code> <code>--terminal-theme</code> <code>TERMINAL_THEME</code> <code>terminal_theme</code> <code>--snippet-theme</code> <code>SNIPPET_THEME</code> <code>snippet_theme</code> <code>--use-pty</code> <code>USE_PTY</code> <code>use_pty</code> <code>--created-files</code> <code>CREATED_FILES</code> - <code>--deleted-files</code> <code>DELETED_FILES</code> - <code>--verbose</code> <code>LOG_VERBOSE</code> <code>log_verbose</code> * <code>--save-log</code> <code>LOG_SAVE</code> - <code>--log-file</code> <code>LOG_FILENAME</code> - - - <code>commit_changes</code> * - - <code>error_changes</code> * - - <code>title</code> \u2020 - - <code>extra_env</code> \u2020 - - <code>skip</code> \u2020 <ul> <li><code>*</code> - GitHub Action only</li> <li><code>\u2020</code> - Markdown / config only (per-output, not global)</li> </ul>"},{"location":"config/overview/#description-of-options","title":"Description of options","text":"<p>A brief description of each option follows.</p> <p>Note</p> <p>Hopefully all config options will be either fairly self-explanitory and/or documented in more details elsewhere. If not, please open an issue on GitHub</p> <ul> <li><code>--search-include</code>: Glob patterns to search for rich-codex comments</li> <li><code>--search-exclude</code>: Glob patterns to exclude from search for rich-codex comments</li> <li><code>--no-search</code>: Set to disable searching for rich-codex comments</li> <li><code>--command</code>: Specify a command to run to capture output</li> <li><code>--timeout</code>: Maximum run time for command (seconds)</li> <li><code>--hide-command</code>: Hide the terminal prompt with the command at the top of the output</li> <li><code>--title-command</code>: Use the command as the terminal title if not set explicitly</li> <li><code>--head</code>: Show only the first N lines of output</li> <li><code>--tail</code>: Show only the last N lines of output</li> <li><code>--trim-after</code>: Don't print any more lines after this string is found</li> <li><code>--truncated-text</code>: Text to show when --head or --tail truncate content</li> <li><code>--snippet</code>: Literal code snippet to render</li> <li><code>--snippet-syntax</code>: Language to use for snippet sytax highlighting</li> <li><code>--img-paths</code>: Path to image filenames if using 'command' or 'snippet'</li> <li><code>--clean-img-paths</code>: Remove any matching files that are not generated</li> <li><code>--configs</code>: Paths to YAML config files</li> <li><code>--skip-git-checks</code>: Skip safety checks for git repos</li> <li><code>--no-confirm</code>: Set to skip confirmation prompt before running commands</li> <li><code>--min-pct-diff</code>: Minimum file percentage change required to update image</li> <li><code>--skip-change-regex</code>: Skip image update if file changes match regex</li> <li><code>--terminal-width</code>: Width of the terminal</li> <li><code>--terminal-min-width</code>: Minimum width of the terminal when trimming</li> <li><code>--notrim</code>: Disable automatic trimming of terminal width</li> <li><code>--terminal-theme</code>: Colour theme</li> <li><code>--snippet-theme</code>: Snippet Pygments theme</li> <li><code>--use-pty</code>: Use a pseudo-terminal for commands (may capture coloured output)</li> <li><code>--created-files</code>: Save a list of created files to this file</li> <li><code>--deleted-files</code>: Save a list of deleted files to this file</li> <li><code>--verbose</code>: Print verbose output to the console.</li> <li><code>--save-log</code>: Save a verbose log to a file (automatic filename).</li> <li><code>--log-file</code>: Save a verbose log to a file (specific filename).</li> <li><code>commit_changes</code>: Automatically commit changes to the repository</li> <li><code>error_changes</code>: Exit with an error if changes are found (Ignored if <code>commit_changes</code> is true)</li> <li><code>title</code>: Title for the terminal title bar</li> <li><code>skip</code>: Skip / ignore this image</li> </ul>"},{"location":"config/time_limits/","title":"Time limits","text":"<p>As rich-codex runs commands within a non-interactive subshell, any command that requires input could cause the tool to hang forever.</p> <p>To avoid this, rich-codex sets a maximum time limit on all commands (default: <code>5 seconds</code>). Once a command runs for this time, it is killed and the screenshot is created with whatever output was captured up to that point.</p> <p>The amount of time that rich-codex waits for can be configured using <code>--timeout</code> / <code>$TIMEOUT</code> / <code>timeout</code> (CLI, env var, action/config).</p>"},{"location":"config/tweaks/","title":"Tweaks","text":""},{"location":"config/tweaks/#snippet-syntax","title":"Snippet syntax","text":"<p>If snippets can be parsed as JSON, they will be automatically reformatted (pretty-printed) and set to use JSON code syntax colouring. Otherwise they will be printed as white text by default.</p> <p>To use coloured syntax highlighting on your non-JSON code snippets, you need to tell rich-codex what syntax to use with the <code>--snippet-syntax</code> / <code>$SNIPPET_SYNTAX</code> / <code>snippet_syntax</code> option (CLI, env var, action/config).</p> <p>Syntax highlighting is done using rich which uses Pygments. Any language supported by Pygments should work.</p> <p><pre><code>&lt;!-- RICH-CODEX\nsnippet_syntax: \"C++\"\nsnippet: |\n    include &lt;iostream&gt;\n\n    int main() {\n        std::cout &lt;&lt; \"Hello World!\";\n        return 0;\n    }\n--&gt;\n![c++ example](../img/snippet-syntax.svg)\n</code></pre> </p>"},{"location":"config/tweaks/#hiding-the-command","title":"Hiding the command","text":"<p>By default, rich-codex shows a command prompt with the command that was used to generate the iamge. This can be disabled by setting using <code>--hide-command</code> / <code>$HIDE_COMMAND</code> / <code>hide_command</code> (CLI, env var, action/config).</p> <p>Default:</p> <p><pre><code>![`echo \"See the command printed at the top?\"`](../img/hide-command-default.svg)\n</code></pre> </p> <p>With <code>hide_command</code> set to <code>true</code>:</p> <pre><code>&lt;!-- RICH-CODEX hide_command: true --&gt;\n![`echo \"What command was used? It's a mystery..\"`](../img/hide-command.svg)\n</code></pre> <p></p>"},{"location":"config/tweaks/#showing-the-command-in-the-title","title":"Showing the command in the title","text":"<p>Rich-codex sets the title in the screenshot only if you provide it (config or as title text in the markdown image). If you like you can tell rich-codex to always use a title, with the command (or fake command) used if the title is not explicitly set.</p> <p>Do this with the <code>--title-command</code> / <code>$TITLE_COMMAND</code> / <code>title_command</code> (CLI, env var, action/config).</p> <p>Default:</p> <p><pre><code>![`echo \"No custom title set\"`](../img/title-command-default.svg)\n</code></pre> </p> <p>With <code>title_command</code> set to <code>true</code>:</p> <p><pre><code>&lt;!-- RICH-CODEX title_command: true --&gt;\n![`echo \"Look ma, a title\"`](../img/title-command.svg)\n</code></pre> </p>"},{"location":"config/tweaks/#truncating-content","title":"Truncating content","text":"<p>If your tool produces a lot of output you can show just the beginning or end of output. You can set the number of lines of output that you would like to show using: (CLI, env var, action/config)</p> <ul> <li><code>--head</code> / <code>$RC_HEAD</code> / <code>head</code></li> <li><code>--tail</code> / <code>$RC_TAIL</code> / <code>tail</code></li> </ul> <p><pre><code>&lt;!-- RICH-CODEX { head: 10, tail: 8 } --&gt;\n![`rich ../../src/rich_codex/codex_search.py`](../img/head-tail.svg \"codex_search.py\")\n</code></pre> </p> <p>If the number you set is larger than the amount of output then all output will be shown as usual.</p> <p>Tip</p> <p>Remember that you can set both head and tail to remove just the middle section of output \ud83d\ude80</p> <p>By default, if any output is truncated a line will be printed: <code>[..truncated..]</code>. You can customise this text using <code>--truncated-text</code> / <code>$TRUNCATED_TEXT</code> /\u00a0<code>truncated_text</code>. Set it to <code>None</code> to omit the line completely.</p>"},{"location":"config/tweaks/#trimming-content","title":"Trimming content","text":"<p>You can clean off unwanted content based on a string pattern match using <code>--trim-after</code> / <code>$TRIM_AFTER</code> / <code>trim_after</code>.</p> <p>Set it to a string - if that string is found in the input, no more lines will be printed after that.</p> <p>No <code>truncated_text</code> is shown for this method currently (could be added if anyone wants it).</p> <p><pre><code>&lt;!-- RICH-CODEX { trim_after: \"class CodexSearch:\", truncated_text: \"Where did the rest of the file go? \ud83d\udd75\ufe0f\u200d\u2640\ufe0f\" } --&gt;\n![`rich ../../src/rich_codex/codex_search.py`](../img/trim-after_truncated-text.svg \"codex_search.py\")\n</code></pre> </p>"},{"location":"config/width/","title":"Terminal Width","text":""},{"location":"config/width/#trimming","title":"Trimming","text":"<p>By default, rich-codex will run your command / parse your snippet and check the length of all output lines. The terminal width will be set to that of the longest line.</p> <p>A mimimum width is used to prevent very narrow images. The default for this is <code>80</code> characters and can be customised using <code>--terminal-min-width</code> / <code>$TERMINAL_MIN_WIDTH</code> / <code>terminal_min_width</code> (CLI, env var, action/config).</p> <p>To turn off trimming, use <code>--notrim</code> / <code>$NOTRIM</code> / <code>notrim</code>.</p> <p>Info</p> <p>Note that console output that is padded with spaces will use the full terminal width available. Much of the output from the rich library is padded.</p> <p>In these cases, you will need to consult the upstream tool on how to set terminal width and match that in rich-codex.</p>"},{"location":"config/width/#fixing-terminal-width","title":"Fixing terminal width","text":"<p>You can define a specific width to use for the terminal image using <code>--terminal-width</code> / <code>$TERMINAL_WIDTH</code> / <code>terminal_width</code> (CLI, env var, action/config). This is typically joined with <code>--notrim</code> to disable automatic trimming.</p> <p>If your console output doesn't match this width, you may get weird effects such as cropping or wrapping. You will probably want to try to match this width with upstream tools.</p> <p>Tip</p> <p>Some tools (such as rich-click) also honour the environment variable <code>$TERMINAL_WIDTH</code></p>"},{"location":"inputs/config_file/","title":"Config file","text":""},{"location":"inputs/config_file/#yaml-config-files","title":"YAML config files","text":"<p>If you prefer, you can configure rich-codex outputs within YAML config files.</p>"},{"location":"inputs/config_file/#config-file-locations","title":"Config file locations","text":"<p>By default, rich-codex looks for files in the following locations (relative to where it runs):</p> <ul> <li><code>.rich-codex.yml</code></li> <li><code>.github/rich-codex.yml</code></li> <li><code>docs/img/rich-codex.yml</code></li> </ul> <p>You can pass one or more additional config locations (separated with newlines) using <code>--configs</code> / <code>RC_CONFIGS</code> / <code>rc_configs</code> (command line / environment variable / GitHub action key).</p> <p>Any files that are not found (including those supplied in addition to the defaults) will be silently ignored.</p> <p>Note</p> <p>Strange things may happen if you have more than one config file, such as global config settings overwriting one another in unpredictable ways. So it's probably best not to use more than one.</p>"},{"location":"inputs/config_file/#validation","title":"Validation","text":"<p>When found, rich-codex will first parse the YAML and validate using the bundled schema. If any validation errors are found, rich-codex will provide a log and exit with an error.</p>"},{"location":"inputs/config_file/#structure","title":"Structure","text":"<p>Config files can have both top-level configuration options that apply to all files and also an <code>outputs</code> array of different things to create.</p> <p>Each <code>outputs</code> array item must contain an <code>img_paths</code> array of output filenames and either a <code>command</code> or a <code>snippet</code>. You can optionally add <code>title</code> to customise the terminal window title.</p> <p>For example:</p> <pre><code>outputs:\n  - command: \"cat docs/cat.txt | lolcat -S 1\"\n    title: Image from a config\n    img_paths:\n      - docs/img/cat.png\n  - snippet: |\n      #!/usr/bin/env python3\n      # -*- coding: utf-8 -*-\n\n      from rich_codex.cli import main\n\n      if __name__ == \"__main__\":\n          main()\n    img_paths:\n      - docs/img/main_header.svg\n</code></pre> <p>There are many other config keys also available. See the configuration docs for more details.</p>"},{"location":"inputs/config_file/#install-ide-validation","title":"Install IDE Validation","text":"<p>You can validate your <code>.rich-codex.yml</code> files in your IDEs using JSONSchema.</p>"},{"location":"inputs/config_file/#vscode","title":"VSCode","text":"<ol> <li> <p>Install the VSCode-YAML extension</p> </li> <li> <p>In your repo, create a <code>.vscode/settings.jsonc</code> or <code>.vscode/settings.template.jsonc</code> file containing the following data. This is what tells the extension which schema to associate with each file.</p> </li> </ol> <pre><code>{\n  \"yaml.schemas\": {\n    \"https://raw.githubusercontent.com/ewels/rich-codex/main/src/rich_codex/config-schema.yml\": [\n      \".rich-codex.yml\",\n      \".rich-codex.yaml\"\n    ]\n  }\n}\n</code></pre> <ol> <li>To prompt other users to install the YAML extension, create a <code>.vscode/extensions.json</code> file containing the following data inside your repo:</li> </ol> <pre><code>{\n  \"recommendations\": [\"redhat.vscode-yaml\"]\n}\n</code></pre>"},{"location":"inputs/config_file/#jetbrains-pycharm-intellij-etc","title":"JetBrains (PyCharm, IntelliJ, etc.)","text":"<p>There are two ways to set this up.</p> <p>You can either add the following data to your <code>.idea/jsonSchemas.xml</code>:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project version=\"4\"&gt;\n  &lt;component name=\"JsonSchemaMappingsProjectConfiguration\"&gt;\n    &lt;state&gt;\n      &lt;map&gt;\n        &lt;entry key=\"rich_codex\"&gt;\n          &lt;value&gt;\n            &lt;SchemaInfo&gt;\n              &lt;option name=\"generatedName\" value=\"New Schema\" /&gt;\n              &lt;option name=\"name\" value=\"rich-codex\" /&gt;\n              &lt;option name=\"relativePathToSchema\" value=\"https://raw.githubusercontent.com/ewels/rich-codex/main/src/rich_codex/config-schema.yml\" /&gt;\n              &lt;option name=\"patterns\"&gt;\n                &lt;list&gt;\n                  &lt;Item&gt;\n                    &lt;option name=\"path\" value=\".rich-codex.yml\" /&gt;\n                  &lt;/Item&gt;\n                  &lt;Item&gt;\n                    &lt;option name=\"path\" value=\".rich-codex.yaml\" /&gt;\n                  &lt;/Item&gt;\n                &lt;/list&gt;\n              &lt;/option&gt;\n            &lt;/SchemaInfo&gt;\n          &lt;/value&gt;\n        &lt;/entry&gt;\n      &lt;/map&gt;\n    &lt;/state&gt;\n  &lt;/component&gt;\n&lt;/project&gt;\n</code></pre> <p>Or you can do this manually in Preferences &gt; Languages &amp; Frameworks &gt; Schemas and DTDs &gt; Json Schema Mappings:</p> <ul> <li>Name: <code>rich-codex</code></li> <li>Schema File or URL: <code>https://raw.githubusercontent.com/dbt-labs/dbt-jsonschema/main/schemas/dbt_project.json</code></li> <li>Schema Version: JSON schema version 4</li> <li>Mappings:</li> <li><code>.rich-codex.yml</code></li> <li><code>.rich-codex.yaml</code></li> </ul>"},{"location":"inputs/direct_inputs/","title":"Direct inputs","text":""},{"location":"inputs/direct_inputs/#command-line-action-inputs","title":"Command-line / action inputs","text":"<p>You can generate images by providing a command or snippet directly to the CLI at run time.</p> <p>You need the following command line flags / environment variables / GitHub Action inputs:</p> <p>One of:</p> <ul> <li><code>--command</code> / <code>$COMMAND</code> / <code>command</code></li> <li><code>--snippet</code> / <code>$SNIPPET</code> / <code>snippet</code></li> </ul> <p>And:</p> <ul> <li><code>--img-paths</code> / <code>$IMG_PATHS</code> / <code>img_paths</code></li> </ul> <p>For example:</p> <pre><code>rich-codex --command 'my-command --yay' --img-paths 'docs/example.svg'\n</code></pre>"},{"location":"inputs/markdown/","title":"Markdown","text":""},{"location":"inputs/markdown/#running-commands","title":"Running commands","text":"<p>If you write markdown with images that contain just a <code>backtick command</code> as the alt-text, rich-codex will find them.</p> <p>For example, the following markdown will generate <code>../img/rich-codex-help.svg</code> (the image shown above) based on the output of the command <code>rich-codex --help</code>:</p> <pre><code>![`rich-codex --help`](../img/rich-codex-help.svg)\n</code></pre> <p></p>"},{"location":"inputs/markdown/#printing-files","title":"Printing files","text":"<p>You can use any command-line tool to print files for screenshots. A good option is rich-cli, which you can use to easily produce screenshots of files with the <code>rich</code> command with nice syntax highlighting:</p> <p>Tip</p> <p>You probably want to hide the command with <code>hide_command</code> - see below for more about configuration.</p> <pre><code>&lt;!-- RICH-CODEX hide_command: true --&gt;\n![`rich ../../src/rich_codex/rich_img.py --tail 20 --force-terminal`](../img/rich-codex-snippet.svg)\n</code></pre> <p></p> <p>Tip</p> <p>\ud83d\udca1 Use the <code>--force-terminal</code> flag to keep colours in your screenshots</p> <p>Note</p> <p><code>rich-codex</code> used to bundle <code>rich-cli</code> as a requirement, but this was dropped in v1.2.7</p>"},{"location":"inputs/markdown/#title-text","title":"Title text","text":"<p>You can also add markdown image title text in quotes after the filename, which will be used in the top menu bar of the screenshot terminal. (Alternatively, set the <code>title</code> config option in a comment).</p> <p>This can be useful when adding lots of command markup to get a good screenshot. You might also want to hide the command prompt. For example:</p> <pre><code>You don't always want people to see the exact command you used, after all.\n&lt;!-- RICH-CODEX hide_command: true --&gt;\n![`rich ../../src/rich_codex/rich_img.py --tail 20 --force-terminal --guides --panel rounded --panel-style magenta --theme monokai`](../img/rich-codex-snippet-title.svg \"rich_img.py\")\n</code></pre> <p></p>"},{"location":"inputs/markdown/#config-comments","title":"Config comments","text":"<p>You can use a HTML comment in a line above the image to set config attributes for this image only. The comment should begin with <code>RICH-CODEX</code> and then have valid YAML after that.</p> <p>The parsed configuration will be validated - see an overview of available variables on the config overview docs.</p> <p>For example:</p> <pre><code>&lt;!-- RICH-CODEX {terminal_width: 60, terminal_theme: MONOKAI} --&gt;\n![`cowsay -t \"Taste the rainbow\" | lolcat -S 100`](../img/taste-the-rainbow.svg \"Taste the rainbow\")\n</code></pre> <p></p>"},{"location":"inputs/markdown/#code-snippets","title":"Code snippets","text":"<p>In addition to running commands, you can format code blocks or \"snippets\".</p> <p>To do this, make the <code>&lt;!-- RICH-CODEX</code> code comment config with the <code>snippet</code> key. Remember that you can use the pipe character <code>|</code> in YAML to have multi-line strings, but you need to be careful with indentation to maintain valid YAML. I'd recommend you write the YAML in a code editor with syntax highlighting and then paste it in.</p> <p>Info</p> <p>The alt-text for the markdown image embed doesn't matter for snippets. However, if it has a command in backticks then this will take priority over the snippet.</p> <p>If the snippet is valid JSON, it will be pretty-printed and coloured. Otherwise text will default to white.</p> <p><pre><code>&lt;!-- RICH-CODEX\nsnippet: |\n  {\"menu\": {\n    \"id\": \"file\", \"value\": \"File\",\n    \"popup\": {\n      \"menuitem\": [\n        {\"value\": \"New\", \"onclick\": \"CreateNewDoc()\"},\n        {\"value\": \"Open\", \"onclick\": \"OpenDoc()\"},\n        {\"value\": \"Close\", \"onclick\": \"CloseDoc()\"}\n      ]\n    }\n  }}\n--&gt;\n![my JSON snippet](../img/example-json-snippet.svg)\n</code></pre> </p> <p>For other code languages, use <code>snippet_syntax</code> to define which language to format in. For example:</p> <p><pre><code>&lt;!-- RICH-CODEX\nsnippet_syntax: python\nsnippet: |\n  &gt;&gt;&gt; print(\"[italic red]Hello[/italic red] World!\", locals())\n  Hello World!\n  {\n      '__annotations__': {},\n      '__builtins__': &lt;module 'builtins' (built-in)&gt;,\n      '__doc__': None,\n      '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;,\n      '__name__': '__main__',\n      '__package__': None,\n      '__spec__': None,\n      'print': &lt;function print at 0x1027fd4c0&gt;,\n  }\n--&gt;\n![](../img/example-python-snippet.svg)\n</code></pre> </p>"},{"location":"usage/cli/","title":"Command-line","text":"<p>In addition to the GitHub Action, rich-codex is also a stand-alone command line tool.</p> <p>You are welcome to use it locally, for example when first writing new documentation and generating initial images to check their output.</p> <p>\ud83d\udca5\u26a0\ufe0f Warning \u26a0\ufe0f\ud83d\udca5</p> <p>Please remember that rich-codex is designed to run arbitrary commands that it finds within documentation for your project.</p> <p>You alone are responsible for any damage you cause to your computer! \ud83d\ude43 Running rich-codex entirely within GitHub Actions is recommended \ud83d\udc4d\ud83c\udffb</p>"},{"location":"usage/cli/#local-installation","title":"Local installation","text":"<p>You can install <code>rich-codex</code> from the Python Package Index (PyPI) with <code>pip</code> or equivalent.</p> <pre><code>pip install rich-codex\n</code></pre> <p>At its simplest, the command-line tool runs without any arguments and recursively searches the current working directory for anything it recognises:</p> <pre><code>rich-codex\n</code></pre> <p>Behaviour can be customised with command-line flags or by setting environment variables, see <code>rich-codex --help</code>:</p> <p></p>"},{"location":"usage/cli/#requirements-for-png-pdf-outputs","title":"Requirements for PNG / PDF outputs","text":"<p>If you wish to generate <code>PNG</code> or <code>PDF</code> images (not just <code>SVG</code>) then there are a few additional requirements. Conversion is done using CairoSVG. First, install rich-codex with the <code>cairo</code> extra:</p> <pre><code>pip install rich-codex[cairo]\n</code></pre> <p>You'll then probably need some additional libraries, see the Cairo documentation:</p> <p>CairoSVG and its dependencies may require additional tools during the installation: a compiler, Python headers, Cairo, and FFI headers. These tools have different names depending on the OS you are using, but:</p> <ul> <li>on Windows, you\u2019ll have to install Visual C++ compiler for Python and Cairo;</li> <li>on macOS, you\u2019ll have to install cairo and libffi (eg. with Homebrew: <code>brew install cairo</code>);</li> <li>on Linux, you\u2019ll have to install the cairo, python3-dev and libffi-dev packages (names may vary for your distribution).</li> </ul> <p>Installation can be messy, so be prepared to do a bit of googling to get things to work. Remember that running rich-codex with the <code>-v</code> flag to get verbose logging can give you more information about what's going wrong (if anything).</p> <p>You'll also need Fira Code installed, an open-licence font: GitHub repo / Google Fonts.</p>"},{"location":"usage/docker_image/","title":"Docker image","text":"<p>There is a docker image for running rich-codex, available on GitHub:</p> <pre><code>docker pull ghcr.io/ewels/rich-codex:latest\n</code></pre> <ul> <li>The label <code>latest</code> will pull the most recent release</li> <li>The label <code>main</code> will pull the development version</li> <li>Releases will have their own specific labels.</li> </ul> <p>Warning</p> <p>If you're trying to run commands, they will likely not be available in the container! So this image is best used for code snippets or common linux tools. Alternatively, you can build your own docker image using this as a base, with additional dependencies installed: <code>FROM ghcr.io/ewels/rich-codex:latest</code></p> <p>To run, a typical command would be:</p> <pre><code>docker run -i -v `pwd`:`pwd` -w `pwd` -u $(id -u):$(id -g) ghcr.io/ewels/rich-codex\n</code></pre> <ul> <li>The <code>-i</code> flag enables stdin so that you can confirm running commands (alternatively, use <code>--no-confirm</code> at the end)</li> <li>The <code>-v</code> argument tells Docker to bind your current working directory (<code>pwd</code>) to the same path inside the container, so that files created there will be saved to your local file system outside of the container.</li> <li><code>-w</code> sets the working directory in the container to this path, so that it's the same as your working directory outside of the container.</li> <li><code>-u</code> sets your local user account as the user inside the container, so that any files created have the correct ownership permissions.</li> </ul> <p>You can then pass environment variables with the <code>-e</code> flag to customise behaviour. See the usage instructions below for the available environment variables.</p>"},{"location":"usage/github_action/","title":"GitHub Action","text":"<p>Rich-codex was primarily designed to run automatically with GitHub actions, to keep your screenshots up to date for you.</p> <p>If there are changes to the images, the action can exit with an error (default) or automatically commit the updates.</p> <p>Info</p> <p>For GitHub Actions to push commits to your repository, you'll need to set Workflow permissions to Read and write permissions under Actions -&gt; General in the repo settings. See the GitHub docs.</p>"},{"location":"usage/github_action/#example-workflow","title":"Example workflow","text":"<p>This action looks for rich-codex content in the repo. It removes any SVG files found in <code>docs/img/</code> that don't match the outputs and generates the updated images. If there have been any changes, it pushes a new commit with the updated images.</p> .github/workflows/screenshots.yml<pre><code>name: Rich-codex\non: [push]\njobs:\n  rich_codex:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out the repo\n        uses: actions/checkout@v3\n\n      - name: Install your custom tools\n        run: pip install .\n\n      - name: Generate terminal images with rich-codex\n        uses: ewels/rich-codex@v1\n        with:\n          commit_changes: \"true\"\n          clean_img_paths: docs/img/*.svg\n</code></pre> <p>Tip</p> <p>The <code>@v1</code> installs the latest rich-codex release under the <code>v1.x.x</code> version. Rich-codex uses semantic versioning, so this means that your workflow will use the most up to date version without the risk of having breaking changes (which would warrant a <code>v2.x.x</code> release number).</p>"},{"location":"usage/github_action/#triggers","title":"Triggers","text":"<p>In the above example, the workflow is triggered by the line <code>on: [push]</code>. This means that new screenshots will be generated on every commit.</p> <p>For some people this may be a little excessive, in which case you might prefer some of the following suggestions.</p> <p>Warning</p> <p>If you have <code>commit_changes: \"true\"</code> set as in the example above, you should only run in environments where pushing a new commit is possible. For example, using this in a workflow triggered by a release will fail because the workflow will be running on a detached commit.</p> <p>Note that GitHub has extensive documentation on the different ways to trigger actions workflows.</p> <p>Tip</p> <p>You can mix and match multiple different triggers!</p>"},{"location":"usage/github_action/#if-specific-files-are-edited","title":"If specific files are edited","text":"<p>If you only want to re-render screenshots if certain files (or filetypes) are edited, you can filter the <code>push</code> event with the <code>paths</code> key:</p> <pre><code>on:\n  push:\n    paths:\n      - \"**.md\"\n      - .rich-codex.yml\n      - src/myapp/cli-flags.py\n</code></pre>"},{"location":"usage/github_action/#specific-branches","title":"Specific branches","text":"<p>You can run on pushes to the <code>main</code> and <code>staging</code> branches only by using:</p> <pre><code>on:\n  push:\n    - main\n    - staging\n</code></pre>"},{"location":"usage/github_action/#manually-running","title":"Manually running","text":"<p>You can manually run the workflow by pressing a button in the GitHub website. Just use:</p> <pre><code>on: workflow_dispatch\n</code></pre>"},{"location":"usage/github_action/#filtering-for-commit-message","title":"Filtering for commit message","text":"<p>You can filter by commit message by always running on every push, but then using an <code>if</code> statement on the job.</p> <p>For example, we can take the main example above and add the following to only run when the commit message includes the string <code>[screenshots]</code>:</p> .github/workflows/screenshots.yml<pre><code>name: Rich-codex\non: [push]\njobs:\n  rich_codex:\n    if: \"contains(github.event.head_commit.message, '[screenshots]')\"\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check out the repo\n        uses: actions/checkout@v3\n\n      - name: Install your custom tools\n        run: pip install .\n\n      - name: Generate terminal images with rich-codex\n        uses: ewels/rich-codex@v1\n        with:\n          commit_changes: \"true\"\n          clean_img_paths: docs/img/*.svg\n</code></pre>"},{"location":"usage/github_action/#github-action-inputs","title":"GitHub Action Inputs","text":"<p>Basically everything that you can configure via the command line interface / config can also be configured within GitHub actions via the <code>with</code> key.</p> <p>For a full description of all available inputs, please see the configuration overview docs.</p>"}]}